<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vodojem P치vice</title>
<style>
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    max-width: 900px;
    margin: 20px auto;
    background: #f9fafb;
    color: #333;
  }

  header {
    display: flex;
    align-items: center;
    gap: 20px;
    background: white;
    padding: 20px 25px;
    border-radius: 18px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    margin-bottom: 25px;
  }

  .signal-icon {
    font-size: 80px;
    background: #0078d7;
    color: white;
    width: 95px;
    height: 95px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 0 15px #0078d7aa;
  }

  .header-text {
    flex-grow: 1;
  }

  .header-text h1 {
    margin: 0 0 8px 0;
    font-weight: 700;
    font-size: 2.3rem;
  }

  .signal-strength {
    font-size: 14px;
    color: #555;
    letter-spacing: 0.05em;
  }

  table {
    width: auto;  /* Nech치me tabulku automatick칠 코칤콏ky */
    margin: 0 auto 18px auto; /* vycentrovan치 s margin bottom */
    border-collapse: separate;
    border-spacing: 50px 20px; /* 50px mezera mezi sloupci, 20px mezi 콏치dky */
    background: transparent;
  }

  td {
    background: white;
    border: none;
    padding: 18px 15px;
    text-align: center;
    font-size: 20px;
    font-weight: 600;
    border-radius: 15px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.07);
    vertical-align: middle;
    width: 40%; /* u쮄뫆 bu켿ky pro v캩t코칤 mezeru */
  }

  /* Nadpis + ikonka vedle sebe */
  .title-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    font-size: 22px;
    font-weight: 700;
    color: #0078d7;
    margin-bottom: 12px;
  }

  .title-icon {
    font-size: 32px;
    user-select: none;
  }

  /* Hodnota a jednotka pod sebou */
  .value {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 4px;
  }

  .unit {
    font-size: 18px;
    color: #555;
    font-weight: 500;
  }

  .alert {
    color: #d93025;
  }

  #lastUpdate {
    text-align: right;
    font-size: 15px;
    color: #777;
    margin-bottom: 28px;
    font-style: italic;
  }

  .charts-container {
    display: flex;
    flex-direction: column;
    gap: 25px;
    margin-bottom: 30px;
  }

  canvas {
    background: white;
    border-radius: 20px;
    box-shadow: 0 6px 16px rgba(0,0,0,0.09);
    padding: 20px;
    width: 100% !important;
    height: 350px !important;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  let levelChart, flowChart;
  let lastUpdateTime = null;

  async function fetchData() {
    try {
      const response = await fetch('https://api.thingspeak.com/channels/1214142/feeds.json?results=20&api_key=SGHZ5KIDVYK3BG1M');
      const dataJson = await response.json();
      const feeds = dataJson.feeds;

      if (!feeds || feeds.length === 0) {
        console.error("Data nejsou k dispozici");
        return;
      }

      const latest = feeds[feeds.length - 1];
      lastUpdateTime = new Date(latest.created_at);

      document.getElementById('signalStrength').textContent = latest.field1 || "N/A";

      const level = parseFloat(latest.field2);
      const flow = parseFloat(latest.field3);

      const levelValueEl = document.getElementById('levelValue');
      const flowValueEl = document.getElementById('flowValue');

      levelValueEl.textContent = isNaN(level) ? "N/A" : level.toFixed(1);
      flowValueEl.textContent = isNaN(flow) ? "N/A" : flow.toFixed(2);

      if (!isNaN(level) && level < 100) {
        levelValueEl.classList.add('alert');
      } else {
        levelValueEl.classList.remove('alert');
      }

      if (!isNaN(flow) && flow < 1) {
        flowValueEl.classList.add('alert');
      } else {
        flowValueEl.classList.remove('alert');
      }

      const labels = feeds.map(f => new Date(f.created_at).toLocaleTimeString());
      const levelData = feeds.map(f => parseFloat(f.field2) || 0);
      const flowData = feeds.map(f => parseFloat(f.field3) || 0);

      if (!levelChart) {
        levelChart = new Chart(document.getElementById('levelChart').getContext('2d'), {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: 'Hladina (cm)',
              data: levelData,
              borderColor: '#0078d7',
              backgroundColor: 'rgba(0,120,215,0.15)',
              fill: true,
              tension: 0.3,
              pointRadius: 5,
              pointHoverRadius: 7,
            }]
          },
          options: {
            responsive: true,
            scales: {
              y: { beginAtZero: true }
            },
            plugins: {
              legend: { labels: { font: { size: 16 } } }
            }
          }
        });
      } else {
        levelChart.data.labels = labels;
        levelChart.data.datasets[0].data = levelData;
        levelChart.update();
      }

      if (!flowChart) {
        flowChart = new Chart(document.getElementById('flowChart').getContext('2d'), {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: 'Pr콢tok (L/h)',
              data: flowData,
              borderColor: '#228B22',
              backgroundColor: 'rgba(34,139,34,0.15)',
              fill: true,
              tension: 0.3,
              pointRadius: 5,
              pointHoverRadius: 7,
            }]
          },
          options: {
            responsive: true,
            scales: {
              y: { beginAtZero: true }
            },
            plugins: {
              legend: { labels: { font: { size: 16 } } }
            }
          }
        });
      } else {
        flowChart.data.labels = labels;
        flowChart.data.datasets[0].data = flowData;
        flowChart.update();
      }

      updateLastUpdateTime();

    } catch (err) {
      console.error("Chyba p콏i na캜칤t치n칤 dat: ", err);
    }
  }

  function updateLastUpdateTime() {
    if (!lastUpdateTime) return;

    const now = new Date();
    const diffMs = now - lastUpdateTime;
    const diffMin = Math.floor(diffMs / 60000);

    const text = diffMin === 0 ? 'Aktualizov치no pr치v캩 te캞' :
      `Aktualizov치no p콏ed ${diffMin} minutou${diffMin === 1 ? '' : 'ami'}`;

    document.getElementById('lastUpdate').textContent = text;
  }

  setInterval(() => {
    fetchData();
    updateLastUpdateTime();
  }, 30000);

  window.onload = () => {
    fetchData();
    updateLastUpdateTime();
  };
</script>
</head>
<body>

<header>
  <div class="signal-icon" title="S칤la sign치lu">游니</div>
  <div class="header-text">
    <h1>Vodojem P치vice</h1>
    <div class="signal-strength">S칤la sign치lu: <span id="signalStrength">-</span></div>
  </div>
</header>

<table>
  <tbody>
    <tr>
      <td>
        <div class="title-row">
          <span class="title-icon">游눦</span>
          <span>Hladina</span>
        </div>
        <div class="value alert" id="levelValue">-</div>
        <div class="unit">cm</div>
      </td>
      <td>
        <div class="title-row">
          <span class="title-icon">游뛇</span>
          <span>Pr콢tok</span>
        </div>
        <div class="value" id="flowValue">-</div>
        <div class="unit">L/min</div>
      </td>
    </tr>
  </tbody>
</table>

<div id="lastUpdate"></div>

<div class="charts-container">
  <canvas id="levelChart"></canvas>
  <canvas id="flowChart"></canvas>
</div>

</body>
</html>



